#include <iostream>
#include <initializer_list>
#include <cmath>

using namespace std;
float const Eps=0.001f;


class Point2D
{
public:
  float m_x = 0.0f, m_y = 0.0f;
//----------------------------------------------для удобства координаты открытые
  Point2D() = default;
  Point2D(Point2D const & obj)
    : m_x(obj.m_x), m_y(obj.m_y)
  {}
  Point2D(float x, float y)
    : m_x(x), m_y(y)
  {}
  Point2D(std::initializer_list<float> const & lst)
  {
    float * vals[] = { &m_x, &m_y };
    int const count = sizeof(vals) / sizeof(vals[0]);
    auto it = lst.begin();

    for (int i = 0; i < count && it != lst.end(); i++, ++it)
      *vals[i] = *it;
  }
 
  Point2D & operator = (Point2D const & obj)
  {
    if (this == &obj) return *this;
    m_x = obj.m_x;
    m_y = obj.m_y;
    return *this;
  }
  
  bool operator == (Point2D const & obj) const
  {
    return EqualWithEps(m_x, obj.m_x) && EqualWithEps(m_y, obj.m_y);
  }
  bool operator != (Point2D const & obj) const
  {
    return !operator==(obj);
  }


  bool operator <= (Point2D const & obj) const
  {
    return m_x <= obj.m_x && m_y <= obj.m_y;
  }
  bool operator >= (Point2D const & obj) const
  {
    return m_x >= obj.m_x && m_y >= obj.m_y;
  }
  bool operator < (Point2D const & obj) const
  {
    return m_x < obj.m_x && m_y < obj.m_y;
  }
  bool operator > (Point2D const & obj) const
  {
    return m_x > obj.m_x && m_y > obj.m_y;
  }
private:

  bool EqualWithEps(float v1, float v2) const
  {
    return fabs(v1 - v2) < Eps;
  }
};

class Box2D
{
  public:
    Box2D()=default;
    Box2D(Point2D& ld, Point2D& rt)
    {
      if(ld>rt)
        swap(m_ld, m_rt);

      if(ld<rt)
      {
        m_ld=ld;
        m_rt=rt;
      }
    }
    Box2D(initializer_list<float> const& lst)
    {
      Point2D ld{0.0f, 0.0f};
      Point2D rt{0.0f, 0.0f};

      float *vals[] = { &ld.m_x, &ld.m_y, &rt.m_x, &rt.m_y };
      auto it = lst.begin();
       //запись координат
      for (int i=0; i<4 && it!=lst.end(); i++, ++it)
        *vals[i] = *it;

        //если углы не в том порядке меняем
      if(ld>rt)
        swap(m_ld, m_rt);

      if(ld<rt)
      {
        m_ld=ld;
        m_rt=rt;
      }
    }
     //проверка на пересечение
    bool operator &&(Box2D& Box)
    {
      if(this->m_ld.m_x > Box.m_rt.m_x || this->m_rt.m_x < Box.m_ld.m_x || this->m_rt.m_y < Box.m_ld.m_y || this->m_ld.m_y > Box.m_rt.m_y) return false;
      return true;
    }

    float const left(){return m_ld.m_x;}
    float const right(){return m_rt.m_x;}
    float const top(){return m_rt.m_y;}
    float const bottom(){return m_ld.m_y;}

    bool left(float new_left)
    {
      if(new_left<(this->right()))
      {
        m_ld.m_x=new_left;
        return true;
      }
      return false;
    }
    bool right(float new_right)
    {
      if(new_right>(this->left()))
      {
        m_rt.m_x=new_right;
        return true;
      }
      return false;
    }
    bool top(float new_top)
    {
      if(new_top>(this->bottom()))
      {
        m_rt.m_y=new_top;
        return true;
      }
      return false;
    }
    bool bottom(float new_bottom)
    {
      if(new_bottom<(this->top()))
      {
        m_ld.m_y=new_bottom;
        return true;
      }
      return false;
    }

  private:
    Point2D m_ld={0.0f, 0.0f};//левый нижний угол
    Point2D m_rt={0.0f, 0.0f};//правый верхний угол
};

enum Direction{UP, DOWN};
class Ray2D_G
{
  public:
    Ray2D_G()=default;
    Ray2D_G(Point2D& origin,  Direction direction)
      :m_origin(origin), m_direction(direction)
      {}
    Ray2D_G(float originX, float originY,  Direction direction)
      :m_origin(originX, originY), m_direction(direction)
      {}

    float const X(){return m_origin.m_x;}
    float const Y(){return m_origin.m_y;}
    Direction const direction(){return m_direction;}

    void X(float x){m_origin.m_x=x;}
    void Y(float y){m_origin.m_y=y;}
    void direction(Direction direction){m_direction=direction;}

    bool operator &&(Box2D& Box)
    {
        //если не может попасть теоретически
      if( (m_direction==UP && Box.top()<this->Y()) || (m_direction==DOWN && Box.bottom()>this->Y()) )
        return false;

      if(this->X()>Box.right() || this->X()<Box.left())
        return false;

      return true;
    }
  private:
    Point2D m_origin={0.0f, 0.0f};
    Direction m_direction=UP;

};
